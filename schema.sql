---------------------------------------------
--schema for proejct 1 phase 2 part 1
---------------------------------------------

DROP SCHEMA IF EXISTS schema CASCADE;
CREATE SCHEMA schema;
SET SCHEMA 'schema';

DROP TABLE IF EXISTS STUDENT CASCADE;
DROP TABLE IF EXISTS STUDENT_DIR CASCADE;
DROP TABLE IF EXISTS COURSE CASCADE;
DROP TABLE IF EXISTS COURSE_TAKEN CASCADE;

CREATE TABLE FOREST(
     forest_no INTEGER,
     name VARCHAR(30),
     area INTEGER,
     acid_level REAL,
     MBR_XMin REAL,
     MBR_XMax REAL,
     MBR_YMin REAL,
     MBR_YMax REAL,

      CONSTRAINT FOREST_PK PRIMARY KEY (forest_no)
);
CREATE TABLE STATE(
    --name is the alternative key in state
    name VARCHAR(30) UNIQUE NOT NULL,
    abbreviation CHAR(2),
    area INTEGER,
    population INTEGER,
    MBR_XMin REAL,
    MBR_XMax REAL,
    MBR_YMin REAL,
    MBR_YMax REAL,

         CONSTRAINT STATE_PK PRIMARY KEY (abbreviation)
);
CREATE TABLE WORKER(
    SSN VARCHAR(9),
    first VARCHAR(30),
    last VARCHAR(30),
    middle CHAR(1),
    rank REAL,

     CONSTRAINT WORKER_PK PRIMARY KEY (SSN)
);
CREATE TABLE SENSOR(
    sensor_id INTEGER,
    last_charged TIMESTAMP,
    energy INTEGER,
    last_read TIMESTAMP,
    X REAL,
    Y REAL,
    maintainer_id VARCHAR(9),

            CONSTRAINT SENSOR_PK PRIMARY KEY (sensor_id),
            --if there is no worker maintain, then delete
            CONSTRAINT SENSOR_FK FOREIGN KEY (maintainer_id) REFERENCES WORKER(SSN)
                    ON UPDATE CASCADE ON DELETE CASCADE

--Assumption 4:A WORKER will only exist in ArborDB if they are maintaining at least one SENSOR.
-- Additionally, each SENSOR will always be maintained by a single WORKER.

);

CREATE DOMAIN LIFE_FORM AS VARCHAR(16)
CHECK (VALUE IN ('Phanerophytes', 'Epiphytes', 'Chamaephytes', 'Hemicryptophytes', 'Cryptophytes', 'Therophytes', 'Aerophytes'))

CREATE TABLE TREE_SPECIES(
    genus VARCHAR(30),
    epithet VARCHAR(30),
    ideal_temperature REAL,
    largest_height REAL,
    raunkiaer_life_form LIFE_FORM,
    --PK: Species_name(genus,epithet)
        CONSTRAINT TREE_SPECIES_PK PRIMARY KEY (genus,epithet)
);

--report is a weak entity
CREATE TABLE REPORT(
    sensor_id INTEGER,
    report_time TIMESTAMP,
    temperature REAL,
        --report_time is discriminator partial key of REPORT
        CONSTRAINT REPORT_PK PRIMARY KEY (sensor_id,report_time),
        --report is weak a entity generated by sensor
        CONSTRAINT REPORT_FK FOREIGN KEY (sensor_id) REFERENCES SENSOR(sensor_id)
                    ON UPDATE CASCADE ON DELETE CASCADE

--Assumption 5: A SENSOR can exist in ArborDB without generating a REPORT
-- while a REPORT cannot exist in ArborDB without being generated by a SENSOR.

);
--relation between STATE and WORKER
CREATE TABLE EMPLOYED(
    abbreviation CHAR(2),
    SSN VARCHAR(9),

        CONSTRAINT EMPLOYED_PK PRIMARY KEY (abbreviation,SSN),
        CONSTRAINT EMPLOYED_FK1 FOREIGN KEY (SSN) REFERENCES WORKER (SSN)
                ON UPDATE CASCADE ON DELETE CASCADE,
        CONSTRAINT EMPLOYED_FK2 FOREIGN KEY (abbreviation) REFERENCES STATE (abbreviation)
                ON UPDATE CASCADE ON DELETE CASCADE

);

--WORK PHONE
CREATE TABLE PHONE (
    SSN VARCHAR(9),
    type VARCHAR(30),
    number  VARCHAR(16),

        CONSTRAINT PHONE_PK PRIMARY KEY (type,number),
        --work phone is a MULTIVALUED attribute of WORKER
        CONSTRAINT PHONE_FK FOREIGN KEY (SSN) REFERENCES WORKER(SSN)
                    ON UPDATE CASCADE ON DELETE CASCADE
);



--
CREATE TABLE TREE_COMMON_NAME(
    genus VARCHAR(30),
    epithet VARCHAR(30),
    common_name VARCHAR(30),
         CONSTRAINT TREE_COMMON_NAME_PK PRIMARY KEY (common_name),
         --CORRECT? USE CASCADE?
         CONSTRAINT  TREE_COMMON_NAME_FK FOREIGN KEY (genus,epithet) REFERENCES TREE_SPECIES(genus,epithet)
                    ON UPDATE CASCADE ON DELETE CASCADE

);



--relation between FOREST and STATE
CREATE TABLE COVERAGE
(
    forest_no  INTEGER,
    abbreviation    CHAR(2),
    percentage REAL,
    area       INTEGER,

        CONSTRAINT COVERAGE_PK PRIMARY KEY (forest_no, abbreviation),
        CONSTRAINT COVERAGE_FK1 FOREIGN KEY (forest_no) REFERENCES FOREST (forest_no)
                ON UPDATE CASCADE ON DELETE CASCADE,
        CONSTRAINT COVERAGE_FK2 FOREIGN KEY (abbreviation) REFERENCES STATE (abbreviation)
                ON UPDATE CASCADE ON DELETE CASCADE

);

--relation between FOREST and TREE_SPECIES
CREATE TABLE FOUND_IN (
    forest_no INTEGER,
    genus VARCHAR(30),
    epithet VARCHAR(30),

        CONSTRAINT FOUND_IN_PK PRIMARY KEY (forest_no, genus,epithet),
        CONSTRAINT FOUND_IN_FK1 FOREIGN KEY (forest_no) REFERENCES FOREST (forest_no)
                       ON UPDATE CASCADE ON DELETE CASCADE,
        CONSTRAINT FOUND_IN_FK2 FOREIGN KEY (genus,epithet) REFERENCES TREE_SPECIES (genus,epithet)
                       ON UPDATE CASCADE ON DELETE CASCADE

);

CREATE TABLE CLOCK (
    synthetic_time TIMESTAMP
);

-------------------------------------------Trigger
--Assumption1: FORESTs cannot exist in ArborDB without any TREE SPECIES being found in the FOREST
--but TREE SPECIES can exist in ArborDB without being found in a FOREST (e.g., an extinct TREE SPECIES)

--If there is no tree species, delete the forest
CREATE OR REPLACE FUNCTION func_1()
RETURNS TRIGGER AS
$$
DECLARE
total_species INTEGER;

BEGIN
    SELECT COUNT(*) INTO total_species
    FROM FOUND_IN
    --Check the num of species in a forest after delete
    WHERE forest_no = old.forest_no;

    IF total_species < 1 THEN
        --if this forest have no tree species, delete
        DELETE FROM FOREST WHERE forest_no = old.forest_no;
    end if;
end;
$$ LANGUAGE plpgsql;
--drop the trigger if it exists
DROP TRIGGER IF EXISTS trig_1 ON FOUND_IN;
CREATE TRIGGER trig_1
    AFTER DELETE
    ON FOUND_IN
    FOR EACH ROW
    EXECUTE PROCEDURE func_1();

--Assumption 2:  STATEs can exist in ArborDB without covering any FORESTs
-- but a FOREST must be covered by at least one STATE to exist within ArborDB.
CREATE OR REPLACE FUNCTION func_2()
RETURNS TRIGGER AS
$$
DECLARE
num_state INTEGER;

BEGIN
    SELECT COUNT(*) INTO num_state
    FROM COVERAGE
    --Check if the forest covered by at least one state after delete
    WHERE forest_no = old.forest_no;

    IF num_state < 1 THEN
        --if this forest isn't covered by any state, delete
        DELETE FROM FOREST WHERE forest_no = old.forest_no;
    end if;
end;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trig_2 ON COVERAGE;
CREATE TRIGGER trig_2
    AFTER DELETE
    ON COVERAGE
    FOR EACH ROW
    EXECUTE PROCEDURE func_2();

--Assumption3: A STATE can exist in ArborDB without employing any WORKERs for maintaining FORESTs
-- but a WORKER will only exist in ArborDB if they are employed by a STATE.
--Each WORKER in ArborDB must be employed by at least one STATE.
CREATE OR REPLACE FUNCTION func_3()
RETURNS TRIGGER AS
$$
DECLARE
num_employment INTEGER;

BEGIN
    SELECT COUNT(*) INTO num_employment
    FROM EMPLOYED
    WHERE SSN = old.SSN;

    IF num_employment < 1 THEN
        --if this worker is not employed by any state, delete
        DELETE FROM WORKER WHERE SSN = old.SSN;
    end if;
end;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trig_3 ON EMPLOYED;
CREATE TRIGGER trig_3
    AFTER DELETE
    ON EMPLOYED
    FOR EACH ROW
    EXECUTE PROCEDURE func_3();

--Integrity Constraint:The location of a SENSOR must be deployed with in a STATE that covers the corresponding FOREST.
-- This will be enforced during the implementation.

--The time stamp when a SENSOR was last read by a WORKER is not the same as the times tamp when a SENSOR generated a report.

